<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://lilacrainode.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Jan 2020 19:49:36 +0800</lastBuildDate>
    
	<atom:link href="https://lilacrainode.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>区间贪心学习笔记</title>
      <link>https://lilacrainode.github.io/post/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 21 Jan 2020 19:49:36 +0800</pubDate>
      
      <guid>https://lilacrainode.github.io/post/%E5%8C%BA%E9%97%B4%E8%B4%AA%E5%BF%83%E7%AC%94%E8%AE%B0/</guid>
      <description>本文参考《算法笔记》4.4.2相关内容  对于区间贪心，首先明确一个最基本的原则： 对于这样的两个区间，一定要选I1不能选I2,因为这样会有更大的空间去容纳其他开区间
开始算法的梳理 首先按左端点从大到小排序，如果左端点相同就按右端点从小到大排序
bool cmp(Interval a, Interval b) { if (a.x != b.x) { return a.x &amp;gt; b.x; } //先按左端点从大到小排序 else { return a.y &amp;lt; b.y; } } //定义cmp函数，先按左端点从大到小排序，如果左端点相同就按右端点   排序完成之后，大致的区间图形如下
 第一个区间（左端点最大的区间）一定要选，如果它的右端点比其他任意一个区间的右端点小，那么其含于那一个区间，就是开始提到的最基本的原则中的I1,而如果如图yi&amp;gt;y2的话，多出的部分一定不会影响到任意一个可能要选的区间，可以想象把多出的部分去掉，那么I1就含于I2了，符合最开始的原则，I2将被剔除，这时候可能会想，如果有一个区间像这样怎么办呢
可以看到，这时候I1含于I3，这个区间也一定会被剔除， 选出左端点最大的区间之后，所有与其有交集的区间都不能选，即如果某个区间右端点在I1的左端点右边，这个区间将被剔除。 在剔除所有与其有交集的区间之后，下一个与其没有交集的区间就成为当前排序的I1，重复以上的动作，直到所有的区间都被过一遍，用ans统计该过程中的不相交区间，即得出答案
# include &amp;lt;stdio.h&amp;gt; # include &amp;lt;string.h&amp;gt; # include &amp;lt;cstdio&amp;gt; # include &amp;lt;iostream&amp;gt; # include &amp;lt;algorithm&amp;gt; using namespace std; const int maxn = 110; struct Interval { int x; int y; } I[maxn]; bool cmp(Interval a, Interval b) { if (a.</description>
    </item>
    
    <item>
      <title>19.9.8算法学习笔记</title>
      <link>https://lilacrainode.github.io/post/19%E5%B9%B49%E6%9C%888%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 21 Jan 2020 18:37:00 +0800</pubDate>
      
      <guid>https://lilacrainode.github.io/post/19%E5%B9%B49%E6%9C%888%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>19.9.8算法学习:冒泡排序 冒泡排序需要进行n-1遍才能使其全部按顺序排好
打开为知笔记快捷键为ctrl+art+m
问题 for int i = 1;i&amp;lt;=4;i++ /*C++*/  这样的代码如何在Python中实现？
python实现冒泡排序 list1 = [3,1,4,5,2] i = 1 j = 0 temp = 0 while i &amp;lt;= 4: i += 1 while j&amp;lt;=3: if list1[j]&amp;lt;list1[j+1]: pass elif list1[j]&amp;gt;list1[j+1]: temp = list1[j+1] list1[j+1] = list1[j] list1[j] = temp else: print(&#39;something went wrong&#39;) j += 1 j = 0 #要把J还原为0，否则J一直等于3 print(list1)  其中循环之后让j变回0非常重要
3n+1猜想  卡拉兹猜想 如果n为偶数，那么把他砍掉一半，如果n为奇数，那么把3n+1砍掉一半
n = int(input()) steps = 0 while n !</description>
    </item>
    
    <item>
      <title>Mysql笔记</title>
      <link>https://lilacrainode.github.io/post/mysql%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 21 Jan 2020 18:32:50 +0800</pubDate>
      
      <guid>https://lilacrainode.github.io/post/mysql%E7%AC%94%E8%AE%B0/</guid>
      <description>asc &amp;mdash;&amp;ndash; ascending order升序 desc &amp;mdash;&amp;ndash; descending order降序 set global interactive_timeout = 1000000;原来是120,为了防止长时间不使用之后断开连接，设置成了100000。  +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+ | Variable_name | Value | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+ | connect_timeout | 10 | | delayed_insert_timeout | 300 | | have_statement_timeout | YES | | innodb_flush_log_at_timeout | 1 | | innodb_lock_wait_timeout | 120 | | innodb_rollback_on_timeout | OFF | | interactive_timeout | 120 | | lock_wait_timeout | 31536000 | | net_read_timeout | 30 | | net_write_timeout | 60 | | rpl_stop_slave_timeout | 31536000 | | slave_net_timeout | 60 | | wait_timeout | 28800 | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;+&amp;mdash;&amp;mdash;&amp;mdash;-+</description>
    </item>
    
  </channel>
</rss>